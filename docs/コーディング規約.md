# LumiDisk コーディング規約

## 概要

このドキュメントは、LumiDiskプロジェクトの開発におけるコーディング規約を定義します。一貫性のあるコード品質を保つため、すべての開発者はこの規約に従ってください。

## 基本方針

- **可読性**: コードは書くよりも読まれる時間の方が長い
- **保守性**: 将来の変更や拡張を考慮した設計
- **一貫性**: プロジェクト全体で統一されたスタイル
- **効率性**: パフォーマンスを考慮した実装

## Java コーディング規約

### 1. 命名規則

#### クラス名
- **PascalCase** を使用
- 名詞で、明確で説明的な名前を付ける
```java
// 良い例
public class FileScanner { }
public class MainController { }

// 悪い例
public class scanner { }
public class MainCtrl { }
```

#### メソッド名
- **camelCase** を使用
- 動詞で始まり、何をするかを明確に表現
```java
// 良い例
public void scanDirectory(Path path) { }
public boolean isFileHidden() { }
public String getFormattedSize() { }

// 悪い例
public void scan(Path p) { }
public boolean hidden() { }
public String size() { }
```

#### 変数名
- **camelCase** を使用
- 意味のある名前を付ける
```java
// 良い例
private final Path selectedPath;
private ScanResult currentScanResult;
private final ExportService exportService;

// 悪い例
private final Path p;
private ScanResult result;
private final ExportService es;
```

#### 定数
- **UPPER_SNAKE_CASE** を使用
```java
// 良い例
private static final String DEFAULT_FILE_EXTENSION = "";
private static final int MAX_DISPLAY_COUNT = 100;

// 悪い例
private static final String defaultFileExtension = "";
private static final int maxDisplayCount = 100;
```

### 2. インデントとフォーマット

#### インデント
- **2スペース** を使用（タブは使用しない）
- 行の長さは **120文字以内** に収める

#### 中括弧の配置
- **K&R スタイル** を使用
```java
// 良い例
public class Example {
  public void method() {
    if (condition) {
      // 処理
    } else {
      // 処理
    }
  }
}

// 悪い例
public class Example 
{
  public void method() 
  {
    if (condition) 
    {
      // 処理
    } 
    else 
    {
      // 処理
    }
  }
}
```

### 3. コメント

#### JavaDoc
- すべてのpublicクラス、メソッド、フィールドにJavaDocを記述
```java
/**
 * ファイル・ディレクトリの情報を保持するモデルクラス
 */
public class FileNode {
  /**
   * ファイルのサイズを取得する
   * @return ファイルサイズ（バイト）
   */
  public long getSize() {
    return size;
  }
}
```

#### インラインコメント
- 複雑なロジックや意図が不明な箇所にコメントを追加
```java
// サイズが0より大きいファイル・ディレクトリのみを対象
files.stream()
    .filter(file -> file.getSize() > 0)
    .sorted((a, b) -> Long.compare(b.getSize(), a.getSize()))
    .limit(displayCount)
    .forEach(file -> {
      // 処理
    });
```

### 4. 例外処理

#### 例外のキャッチ
- 具体的な例外をキャッチし、適切な処理を行う
```java
// 良い例
try {
  Files.walkFileTree(root, visitor);
} catch (IOException e) {
  logger.error("ファイルスキャン中にエラーが発生", e);
  throw new ScanException("スキャンに失敗しました", e);
}

// 悪い例
try {
  Files.walkFileTree(root, visitor);
} catch (Exception e) {
  // 何もしない
}
```

#### ログ出力
- 適切なログレベルを使用
- エラー情報を含める
```java
logger.info("スキャン開始: {}", root);
logger.warn("ファイルアクセスエラー: {}", file, e);
logger.error("スキャン中にエラーが発生", e);
```

### 5. リソース管理

#### try-with-resources
- リソースの自動クローズに使用
```java
// 良い例
try (FileWriter writer = new FileWriter(file)) {
  writer.write(data);
}

// 悪い例
FileWriter writer = new FileWriter(file);
try {
  writer.write(data);
} finally {
  writer.close();
}
```

## JavaFX コーディング規約

### 1. FXML ファイル

#### レイアウト
- 適切なネストとインデントを使用
- コントロールのIDは説明的な名前を付ける
```xml
<!-- 良い例 -->
<Button fx:id="selectDirectoryButton" 
        mnemonicParsing="false" 
        onAction="#handleSelectDirectory" 
        text="ディレクトリ選択" />

<!-- 悪い例 -->
<Button fx:id="btn1" onAction="#handle" text="選択" />
```

### 2. コントローラー

#### フィールドの順序
1. ログインスタンス
2. FXMLコントロール（@FXML付き）
3. その他のフィールド
```java
public class MainController implements Initializable {
  private static final Logger logger = LoggerFactory.getLogger(MainController.class);
  
  @FXML private Button selectDirectoryButton;
  @FXML private TableView<FileNode> fileTable;
  
  private Path selectedPath;
  private ScanResult currentScanResult;
}
```

#### イベントハンドラー
- メソッド名は `handle` + イベント名の形式
```java
@FXML
private void handleSelectDirectory(ActionEvent event) {
  // 処理
}

@FXML
private void handleScan(ActionEvent event) {
  // 処理
}
```

## パフォーマンス規約

### 1. ストリームAPI
- 適切なストリーム操作を使用
```java
// 良い例
var sortedFiles = files.stream()
    .filter(file -> file.getSize() > 0)
    .sorted((a, b) -> Long.compare(b.getSize(), a.getSize()))
    .limit(displayCount)
    .toList();

// 悪い例
List<FileNode> sortedFiles = new ArrayList<>();
for (FileNode file : files) {
  if (file.getSize() > 0) {
    sortedFiles.add(file);
  }
}
sortedFiles.sort((a, b) -> Long.compare(b.getSize(), a.getSize()));
```

### 2. コレクション操作
- 適切なコレクション型を選択
- 不変コレクションを優先
```java
// 良い例
private final List<String> options = List.of("10", "25", "50", "100", "ALL");

// 悪い例
private final List<String> options = new ArrayList<>();
```

## テスト規約

### 1. テストクラス
- テスト対象クラス名 + `Test` の形式
```java
public class FileScannerTest {
  @Test
  public void testScanDirectory() {
    // テストコード
  }
}
```

### 2. テストメソッド
- `test` + テスト対象メソッド名の形式
- 期待値と実際の値を明確に比較
```java
@Test
public void testGetFormattedSize() {
  FileNode file = new FileNode(path, 1024, modified, false, false);
  assertEquals("1.0 KB", file.getFormattedSize());
}
```

## ドキュメント規約

### 1. README.md
- プロジェクトの概要、セットアップ方法、使用方法を記載
- スクリーンショットやデモを含める

### 2. API ドキュメント
- JavaDocを適切に記述
- パラメータ、戻り値、例外を明記

## バージョン管理規約

### 1. コミットメッセージ
- 明確で簡潔なメッセージ
- 変更の種類を明記
```
feat: 円グラフの表示件数調整機能を追加
fix: サイズソートの単位混在問題を修正
docs: コーディング規約ドキュメントを追加
```

### 2. ブランチ命名
- 機能: `feature/機能名`
- バグ修正: `fix/バグ名`
- ドキュメント: `docs/ドキュメント名`

## ツール設定

### 1. IDE設定
- IntelliJ IDEA または Eclipse のコードフォーマッターを設定
- インポート文の整理を有効化

### 2. 静的解析
- SpotBugs、PMD、Checkstyle の使用を推奨
- CI/CD パイプラインに組み込み

## 例外事項

この規約に従うことが困難な場合は、チーム内で相談し、適切な代替案を検討してください。規約の改善提案も歓迎します。

---

**最終更新**: 2025年8月31日  
**バージョン**: 1.0
